/*игра в командной строке
*/


#include <iostream>
#include <string>
#include <iomanip>
#include <fstream>
#include <windows.h>
#include <locale.h>
#include "game.h"
using namespace std;


int main() {
    //SetConsoleCP(1251);
    //SetConsoleOutputCP(1251);
    //setlocale(LC_ALL,"Eng");
    setlocale(LC_ALL,"Rus");
    int z;
    cout << "Enter a name for your prey: ";
    string name,name1;
    cin >> name;
    cout << "Enter a name for your predator: ";
    cin >> name1;
    Prey prey(name,Point2D(1,1));
    Predator predator(name1,Point2D(7,1));
    cout << "За кого хотите играть? (0-жертва, 1-хищник)" << endl;
    cin >> z;

    Arena arena(10,10,&prey,&predator);
    cout << arena << endl;

    while (1) {
        if (z == 0) {
            if (check(prey,predator)) {
                predator.MoveTo(prey.getx(),prey.gety());
                cout << arena;
                cout << "\n!!!!!! ХИЩНИК ПОБЕДИЛ !!!!!!" << endl;
                return 0;
            }
            else {
                prey.AutoMove(arena,z);
                predator.AutoMove(arena,z);
                cout << arena << endl;
            }
        }
        else {
            if (check1(prey,predator)) {
                cout << "\n!!!!!! ХИЩНИК ПОБЕДИЛ !!!!!!" << endl;
                return 0;
            }
            else {
                prey.AutoMove(arena,z);
                predator.AutoMove(arena,z);
                cout << arena << endl;
            }
        }
    }

    return 0;
}
/*
Так как ООП имитирует отношение объектов (феноменов) реального мира, а все реальные объекты связаны между собой,
существуют типичные связи и между объектами в ООП.
Такими типичными связями являются:
Композиция, Агрегация, Ассоциация и Зависимость

Композиции являются одними из самых простых типов отношений для реализации,
так как это обычные структуры или классы с обычными членами.

Как и в случае композиции, отношения в агрегации также являются отношениями части-целого и
однонаправленные.
Однако, в отличие от композиции, части могут принадлежать более чем одному целому в моменте,
и целое не управляет существованием и продолжительностью жизни частей.

В ассоциации объекты между собой формально никак не связаны (один не является частью другого),
но ассоциированные объекты имеют доступ к функционалу друг друга.
(могут быть как однонаправленными, так и двунаправленными)

Зависимость возникает, когда один объект обращается к функционалу другого объекта для
выполнения определенного задания. (слабее ассоциации, всегда является однонаправленной).

Как думаете какие типы взаимодействий уже есть в программе?


Рассмотрим игру Хищник - Жертва (аналог игр шофёр-убийца или человек лев)

Упражнение 1.1. Композиции
Опишите класс Predator аналогично классу Prey.

Упражнение 1.2. Агрегация
Создайте класс Arena. Опишите Конструктор арены принимающий её параметры: длину и ширину,
и находящихся на орене хищников и жертв. Все эти атрибцты должны быть приватными.
Габариты арены являются простыми параметрами.
А хищники и жертвы добавляются как указатели на объекты соответствующих классов, например:

    Prey* prey

Упражнение 1.3. Ассоциация
Добавьте в классы Predator и Prey метод AvtoMove(), отвечающий за автоматическое перемещение.
Это необходимо для имитации игры компьютера за одного из персонажей.
Для работы этого метода добавьте его в каждый из классов персонажей как дружественный по отношению к другому
и имеющий доступ к положению пративника.

Будем считать, что predator может прыгать далеко (например на 5 клеток) но только по горизонтали или вертикали, а
prey ходить на одну клетку в любом направлении. Организуйте соответствующим образом работу метода AvtoMove().
Пока можно пользоваться функцией rand()...

Упражнение 1.4. Зависимость
Мы много раз уже видели отношений в виде зависимости, это пример отношения:  классов и std::cout (типа std::ostream).

Добавьте вывод в консоль координат положения Хищьника и Жертвы, и всей арены целиком (прямоугольник с демонстрацией текущих положений),
перегрузив для каждого из них оператор operator<< ().
Добавьте в main() соответствующую строку:

std::cout << prey << '\n';

Упражнение 1.5. Игра

Добавьте в main() запрос пользователю за кого он хочет играть, и постройте соответствующим образом логику программы. Попробуйте поиграть.


*/